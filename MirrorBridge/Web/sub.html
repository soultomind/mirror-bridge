<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Sub</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 16px;
        }

        #editor {
            width: 100%;
            height: 300px;
        }

        #status {
            margin-top: 8px;
            color: #333;
        }

        #controls {
            margin-top: 8px;
        }

        button {
            margin-right: 8px;
            padding: 6px 10px;
        }

        #connState {
            display: inline-block;
            padding: 6px 10px;
            border-radius: 6px;
            margin-left: 10px;
            font-weight: 600;
        }

        .waiting {
            background: #f0f0f0;
            color: #666;
            border: 1px solid #ddd;
        }

        .connected {
            background: #e6ffed;
            color: #057a3b;
            border: 1px solid #9fe1b7;
        }

        .disconnected {
            background: #ffecec;
            color: #9a1e1e;
            border: 1px solid #f4b0b0;
        }
    </style>
</head>
<body>
    <h2>Sub</h2>
    <textarea id="editor" placeholder="Sub Editor"></textarea>
    <div id="status">상태: 초기</div>

    <div id="controls">
        <button id="connectBtn">연결</button>
        <button id="disconnectBtn" disabled>연결해제</button>
        Sub 상태: <span id="connState" class="waiting">대기</span>
    </div>

    <script src="/js/mirrorbridge.js"></script>
    <script>
        (function () {
            const editor = document.getElementById('editor');
            const status = document.getElementById('status');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            const connStateEl = document.getElementById('connState');

            // autoConnect=false 로 생성하여 버튼으로 제어
            const bridge = new SubMirrorBridge('/js/sharedworker.js', false);

            // 에디터 입력은 연결 상태에서만 브로드캐스트
            function onEditorInput() {
                if (!bridge.isConnected) return;
                bridge.sendNotification('content:update', { text: editor.value }).catch(() => { });
            }

            editor.addEventListener('input', onEditorInput);

            // 연결 상태 변화 처리
            bridge.on('connection', (state) => {
                if (state === 'connected') {
                    status.textContent = '상태: 연결됨';
                    connectBtn.disabled = true;
                    disconnectBtn.disabled = false;
                    connStateEl.textContent = '연결됨';
                    connStateEl.className = 'connected';
                } else if (state === 'disconnected') {
                    status.textContent = '상태: 연결해제';
                    connectBtn.disabled = false;
                    disconnectBtn.disabled = true;
                    connStateEl.textContent = '연결해제';
                    connStateEl.className = 'disconnected';
                    // 연결해제 후 1.5초 뒤 대기 상태로 전환 UI
                    setTimeout(() => {
                        connStateEl.textContent = '대기';
                        connStateEl.className = 'waiting';
                        status.textContent = '상태: 초기';
                    }, 1500);
                }
            });

            // peer 상태(주로 Main 쪽 상태)를 반영하려면 peer:status 이벤트 사용 가능
            bridge.on('peer:status', ({ id, status: st }) => {
                // main만 표시하려면 id 검사
                if (!id || id.toLowerCase() !== 'main') return;
                // 예: 메인 연결 감지 시 UI 표시(선택적)
                // console.log('Main peer status', id, st);
            });

            // Connect 버튼
            connectBtn.addEventListener('click', async () => {
                try {
                    await bridge.connect();
                    status.textContent = '상태: 연결 시도중...';
                    // 연결 직후 editor 내용을 한번 브로드캐스트(옵션)
                    if (editor.value) bridge.sendNotification('content:update', { text: editor.value }).catch(() => { });
                } catch (e) {
                    console.error(e);
                    status.textContent = '상태: 연결 실패';
                }
            });

            // Disconnect 버튼
            disconnectBtn.addEventListener('click', () => {
                bridge.disconnect();
            });

            // 수신된 content:update 처리(자동으로 에디터 업데이트)
            bridge.on('content:update', (payload) => {
                // programmaticUpdate 보호를 기본적으로 사용하지 않으므로 안전하게 적용
                editor.value = payload?.text ?? '';
            });

        })();
    </script>
</body>
</html>